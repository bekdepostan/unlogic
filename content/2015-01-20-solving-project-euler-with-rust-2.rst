Solving Project Euler with Rust 2
#################################

:title: Solving Project Euler with Rust 2
:date: 2015-01-20T00
:modified: 2015-01-20 21
:tags:


Carrying on with `the series <http://unlogic.co.uk/2015/01/12/solving-project-euler-with-rust-1/>`_, here's 
how I solved Project Euler's problem 2:

    Even Fibonacci numbers
    Problem 2
    Each new term in the Fibonacci sequence is generated by adding the previous 
    two terms. By starting with 1 and 2, the first 10 terms will be:

        1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

    By considering the terms in the Fibonacci sequence whose values do not 
    exceed four million, find the sum of the even-valued terms.

Fairly similar to the previous one, in terms that we need to sum a sequence
of filtered numbers. This time though the sequence is not a straight run,
but the fibonacci sequence.

As usual with these issues I assume we will need a recursive function to generate
our fibonacci numbers:

.. code:: rust

	fn fib(n: i32) -> i32{
	    if n == 0 { 
	        return 0;
	    } else if n == 1 {
	        return 1;
	    } else {
	        return fib(n-1) + fib(n-2);
	    }    
	}

As I am still learning Rust, I am not sure if there's more Rustacean way of doing it.
I couldn't find anything relevant to this in the docs, so for now I will leave it 
as it is until I get some feedback on it. I wonder if a closure would be better?

EDIT: From the comments below (thanks pf), this is a much more Rust like implementation IMO:

.. code:: rust

	fn fib(n: i32) -> i32{
	    match n {
	        0 => 0,
	        1 => 1,
	        _ => fib(n-1) + fib(n-2),
	    }    
	}

Now I need to get a list of numbers while the return of the :code:`fib` function 
is < 4,000,000. I cheated a bit here, as I figured out that the max number 
to pass to the function in this case is 34.
I would assume that in the *more correct* way of doing it, the limit is
defined in a better way.

.. code:: rust

	fn main() {
	    let vals = (1..34).map(|x| fib(x));
	}

Thinking back to the previous example I already know about filter and sum.

.. code:: rust

	fn main() {
	    let vals = (1..34).map(|x| fib(x))
	                .filter(|&x| x % 2 == 0)
	                .sum();
	}

But there's a problem:

.. code:: console

	   Compiling euler_2 v0.0.1 (file:////work/sandbox/euler_rust/euler_2)
	/work/sandbox/euler_rust/euler_2/src/main.rs:16:10: 16:15 error: type `core::iter::Filter<i32, core::iter::Map<i32, i32, core::ops::Range<i32>, closure[/work/sandbox/euler_rust/euler_2/src/main.rs:14:32: 14:42]>, closure[/work/sandbox/euler_rust/euler_2/src/main.rs:15:17: 15:31]>` does not implement any method in scope named `sum`
	/work/sandbox/euler_rust/euler_2/src/main.rs:16         .sum();
	                                                        ^~~~~
	error: aborting due to previous error
	Could not compile `euler_2`.
	

Seems like :code:`sum` won't work here due to the :code:`map`. Not to worry, I used :code:`fold` in the previous example,
before the helpful folks at `the rust subreddit <http://reddit.com/r/rust>`_ told me about `sum`,
so let's use that instead, as that should work.

.. code:: rust

	fn main() {
	    let vals = (1..34).map(|x| fib(x))
	                .filter(|&x| x % 2 == 0)
	                .fold(0, |a, b| a + b);
	    
	   println!("{}", vals);
	}

EDIT: :code:`sum` does work, I just forgot to add :code:`use std::iter::AdditiveIterator;` at the 
top of the file. The Github file contains this fix.

Let's run it:

.. code:: console

	cargo run
	     Running `target/euler_2`
	4613732

The result checks out, so Project Euler 2 has been solved.

What I would like to know though: Is there a better way to generate the 
fibonacci sequence? If you have suggestions (or about anything else on this page), 
please leave me a message below. After all, this is a learning exercise for me
and for anyone else interested.

EDIT: With some marvellous feedback (which is a great benefit of posting
these) I have edited the code on Github to use an iterator instead of the recursive call.

The code is now (main credit to /u/emk and others):

.. code:: rust

	use std::iter::AdditiveIterator;
	
	#[derive(Copy)]
	pub struct FibonacciSequence {
	    n_minus_1: u32,
	    n_minus_2: u32
	}
	
	impl Iterator for FibonacciSequence {
	    type Item = u32;
	    fn next(&mut self) -> Option<u32> {
	        let mut result = self.n_minus_1 + self.n_minus_2;
	
	        // Special case: If all our fields are zero, we want to generate
	        // our initial 1.  Everything else will work correctly from here.
	        if result == 0 { result = 1; }
	
	        self.n_minus_2 = self.n_minus_1;
	        self.n_minus_1 = result;
	        Some(result)
	    }
	}
	
	pub fn fibonacci_sequence() -> FibonacciSequence {
	    FibonacciSequence{n_minus_1: 0, n_minus_2: 0}
	}
	
	fn main() {
	    let sum = fibonacci_sequence()
	        .filter(|&v| v % 2 == 0)
	        .take_while(|&v| v <= 4000000u32)
	        .sum();
	
	    println!("Result: {}", sum);
	}

The interesting thing is the performance difference between the iterator
implementation and the recursive call. The recursive implementation timings
are:

    real	0m0.311s
    user	0m0.255s
    sys	0m0.035s

Versus the timings of the iterator:

    real	0m0.079s
    user	0m0.025s
    sys	0m0.035s

Clearly a vast improvement there at the cost of a little extra code. 
With the iterator the benefit stems from the fact that we track where we
are in the sequence. So for each number we don't need to recursively
call the :code:`fib` function until n is 1, which is where the big saving comes from.

This and all future solutions are on `my Github <https://github.com/Svenito/euler_rust>`_

Also posted to `/r/rust <https://www.reddit.com/r/rust/comments/2t23ow/still_learning_rust_following_on_with_a_write_up/>`_
